<?php
/**
 * SurveyManager.
 *
 * @copyright Zikula Development Team
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package SurveyManager
 * @author Zikula Development Team <info@zikula.org>.
 * @link http://zikula.org
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.5.5 (http://modulestudio.de) at Thu Aug 30 15:09:35 CEST 2012.
 */

/**
 * This is the User controller class providing navigation and interaction functionality.
 */
class SurveyManager_Controller_User extends SurveyManager_Controller_Base_User
{
    /**
     * This method is the default function handling the admin area called without defining arguments.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function main($args)
    {
        return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
    }

    /**
     * This method provides a generic item list overview.
     *
     * @param array $args List of arguments.
     * @param string  $ot           Treated object type.
     * @param string  $sort         Sorting field.
     * @param string  $sortdir      Sorting direction.
     * @param int     $pos          Current pager position.
     * @param int     $num          Amount of entries to display.
     * @param string  $tpl          Name of alternative template (for alternative display options, feeds and xml output)
     * @param boolean $raw          Optional way to display a template instead of fetching it (needed for standalone output)
     *
     * @return mixed Output.
     */
    public function view($args)
    {
        $controllerHelper = new SurveyManager_Util_Controller($this->serviceManager);
        
        // parameter specifying which type of objects we are treating
        $objectType = (isset($args['ot']) && !empty($args['ot'])) ? $args['ot'] : $this->request->query->filter('ot', 'survey', FILTER_SANITIZE_STRING);
        $utilArgs = array('controller' => 'user', 'action' => 'view');
        if (!in_array($objectType, $controllerHelper->getObjectTypes('controllerAction', $utilArgs))) {
            $objectType = $controllerHelper->getDefaultObjectType('controllerAction', $utilArgs);
        }

        if ($objectType != 'survey') {
            return parent::view($args);
        }

        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_READ), LogUtil::getErrorMsgPermission());
        $repository = $this->entityManager->getRepository($this->name . '_Entity_' . ucfirst($objectType));
        $viewHelper = new SurveyManager_Util_View($this->serviceManager);
        
        // parameter for used sorting field
        $sort = (isset($args['sort']) && !empty($args['sort'])) ? $args['sort'] : $this->request->query->filter('sort', '', FILTER_SANITIZE_STRING);
        if (empty($sort) || !in_array($sort, $repository->getAllowedSortingFields())) {
            $sort = $repository->getDefaultSortingField();
        }
        
        // parameter for used sort order
        $sdir = (isset($args['sortdir']) && !empty($args['sortdir'])) ? $args['sortdir'] : $this->request->query->filter('sortdir', '', FILTER_SANITIZE_STRING);
        $sdir = strtolower($sdir);
        if ($sdir != 'asc' && $sdir != 'desc') {
            $sdir = 'asc';
        }
        
        $selectionArgs = array(
            'ot' => $objectType,
            'where' => 'tblPages.id IS NOT NULL',
            'orderBy' => $sort . ' ' . $sdir
        );

        $showAllEntries = 1;        
        
        // prepare access level for cache id
        $accessLevel = ACCESS_READ;
        $component = 'SurveyManager:' . ucwords($objectType) . ':';
        $instance = '::';
        if (SecurityUtil::checkPermission($component, $instance, ACCESS_COMMENT)) $accessLevel = ACCESS_COMMENT;
        if (SecurityUtil::checkPermission($component, $instance, ACCESS_EDIT)) $accessLevel = ACCESS_EDIT;
        
        $templateFile = $viewHelper->getViewTemplate($this->view, 'user', $objectType, 'view', $args);
        $cacheId = 'view|ot_' . $objectType . '_sort_' . $sort . '_' . $sdir;

        // retrieve item list without pagination
        $entities = $this->selectEntities($selectionArgs);

        if ($templateFile == 'user/survey/view.tpl') { // not for other formats
            // Loop through each item and display it.
            $renderedSurveys = array();
            foreach ($entities as $survey) {
                $sid = $survey['id'];
                if (!SecurityUtil::checkPermission('SurveyManager:Survey:',"{$sid}::", ACCESS_OVERVIEW)) {
                    continue;
                }
                $this->view->clear_all_assign();
                $previewCacheId = 'survey_preview_' . $sid;
                $this->view->setCacheId($previewCacheId);

                $previewTemplate = 'user/survey/view_preview.tpl';
                if ($this->view->is_cached($previewTemplate)) {
                    $renderedSurveys[$sid] = "<!-- Survey preview {$previewCacheId} cached: -->\n" . $this->view->fetch($previewTemplate);
                } else {
                    $this->view->assign('survey', $survey);
                    $renderedSurveys[$sid] = $this->view->fetch($previewTemplate);
                }
            }
        }

        // set cache id
        $this->view->setCacheId($cacheId . '_all_1_own_' . $showOwnEntries . '_' . $accessLevel);

        // if page is cached return cached content
        if ($this->view->is_cached($templateFile)) {
            return $viewHelper->processTemplate($this->view, 'user', $objectType, 'view', $args, $templateFile);
        }

        if ($templateFile == 'user/survey/view.tpl') {
            $this->view->setCaching(Zikula_View::CACHE_DISABLED);
            $this->view->clear_all_assign();
            $this->view->assign('renderedSurveys', $renderedSurveys)
                    ->assign($repository->getAdditionalTemplateParameters('controllerAction', $utilArgs));
        } else {
            $this->view->assign('items', $entities)
                    ->assign($repository->getAdditionalTemplateParameters('controllerAction', $utilArgs));
        }

        // fetch and return the appropriate template
        return $viewHelper->processTemplate($this->view, 'user', $objectType, 'view', $args, $templateFile);
    }

    /**
     * This method provides a generic item detail view.
     *
     * @param array $args List of arguments.
     * @param string  $ot           Treated object type.
     * @param string  $tpl          Name of alternative template (for alternative display options, feeds and xml output)
     * @param boolean $raw          Optional way to display a template instead of fetching it (needed for standalone output)
     *
     * @return mixed Output.
     */
    public function display($args)
    {
        $controllerHelper = new SurveyManager_Util_Controller($this->serviceManager);
        
        // parameter specifying which type of objects we are treating
        $objectType = (isset($args['ot']) && !empty($args['ot'])) ? $args['ot'] : $this->request->query->filter('ot', 'survey', FILTER_SANITIZE_STRING);
        $utilArgs = array('controller' => 'user', 'action' => 'display');
        if (!in_array($objectType, $controllerHelper->getObjectTypes('controllerAction', $utilArgs))) {
            $objectType = $controllerHelper->getDefaultObjectType('controllerAction', $utilArgs);
        }

        if ($objectType != 'survey') {
            return parent::display($args);
        }

        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_READ), LogUtil::getErrorMsgPermission());
        $repository = $this->entityManager->getRepository($this->name . '_Entity_' . ucfirst($objectType));

        $idFields = ModUtil::apiFunc($this->name, 'selection', 'getIdFields', array('ot' => $objectType));
        
        // retrieve identifier of the object we wish to view
        $idValues = $controllerHelper->retrieveIdentifier($this->request, $args, $objectType, $idFields);
        $hasIdentifier = $controllerHelper->isValidIdentifier($idValues);
        
        // check for unique permalinks (without id)
        $hasSlug = false;
        $slug = '';
        if ($hasIdentifier === false) {
            $entityClass = $this->name . '_Entity_' . ucwords($objectType);
            $meta = $this->entityManager->getClassMetadata($entityClass);
            $hasSlug = $meta->hasField('slug') && $meta->isUniqueField('slug');
            if ($hasSlug) {
                $slug = $this->request->query->filter('slug', '', FILTER_SANITIZE_STRING);
                $hasSlug = (!empty($slug));
            }
        }
        $hasIdentifier |= $hasSlug;
        //$this->throwNotFoundUnless($hasIdentifier, $this->__('Error! Invalid identifier received.'));
        if (!$hasIdentifier) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        $entity = $this->selectEntity(array('ot' => $objectType, 'id' => $idValues, 'slug' => $slug, 'useJoins' => false));
        $this->throwNotFoundUnless($entity != null, $this->__('No such item.'));
        unset($idValues);
        
        // build ModUrl instance for display hooks; also create identifier for permission check
        $currentUrlArgs = array('ot' => $objectType);
        $instanceId = '';
        foreach ($idFields as $idField) {
            $currentUrlArgs[$idField] = $entity[$idField];
            if (!empty($instanceId)) {
                $instanceId .= '_';
            }
            $instanceId .= $entity[$idField];
        }
        $currentUrlArgs['id'] = $instanceId;
        if (isset($entity['slug'])) {
            $currentUrlArgs['slug'] = $entity['slug'];
        }
        $currentUrlObject = new Zikula_ModUrl($this->name, 'user', 'display', ZLanguage::getLanguageCode(), $currentUrlArgs);
        
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', $instanceId . '::', ACCESS_READ), LogUtil::getErrorMsgPermission());

        $id = $entity['id'];
        $page = (isset($args['page']) && !empty($args['page'])) ? $args['page'] : (int) $this->request->query->filter('page', 0, FILTER_VALIDATE_INT);

        // Get the flag that tells us we were missing a required question
        $missingQuestion = SessionUtil::getVar($this->name . '_missing_required');
        if (!empty($missingQuestion)) {
            SessionUtil::delVar($this->name . '_missing_required');
        }

        // Select the survey
        $survey = $entity;
        // Select pages with questions
        $surveyPages = $this->selectEntities(array('ot' => 'page', 'where' => 'tblSurvey.id = \'' . $id . '\''));

        $helper = new SurveyManager_Util_Manual($this->serviceManager);
        $questionHandlers = array();

        // Collect all questions and initialise corresponding handlers
        $allQuestions = array();
        foreach ($surveyPages as $surveyPage) {
            foreach ($surveyPage['questions'] as $question) {
                $allQuestions[$question['id']] = $question;

                $questionTypeClassName = $helper->getQuestionTypeHandler($question['questionType']);
                if (!isset($questionHandlers[$question['questionType']])) {
                    $questionHandlers[$question['questionType']] = new $questionTypeClassName($this->serviceManager);
                }
            }
        }

        // Check the IP count
        $userIpAddress = System::serverGetVar('REMOTE_ADDR');
        $ipCount = $this->getVar('ip_count');
        if ($survey['maxPerIp'] > 0 && $ipCount[$id][$userIpAddress] >= $survey['maxPerIp']) {
            $this->view->setCacheId('ip_maxxed');
            return $this->view->fetch('user/ipMaxxed.tpl');
        }
        // Check the UserId count
        if ($survey['maxPerUserId'] > 0 && UserUtil::isLoggedIn()) {
            // get amount of responses for current survey and user id
            $where = 'tblSurvey.id = \'' . $entity['id'] . '\' AND tbl.createdUserId = \'' . UserUtil::getVar('uid') . '\'';
            $userResponses = ModUtil::apiFunc($this->name, 'selection', 'getEntities', array('ot' => 'response', 'where' => $where));
            $amountOfUserResponses = count($userResponses);
            if ($survey['maxPerUserId'] == $amountOfUserResponses) {
                $this->view->setCacheId('uid_maxxed');
                return $this->view->fetch('user/uidMaxxed.tpl');
            }
        }

        $currentPage = null;
        if (!is_numeric($page) || $page < 1) {
            // If no SID is given, use the first step of the line
            $currentPage = reset($surveyPages);
            $page = $currentPage['id'];
        }

        // Try to find the next page in the sequence.
        $nextPage = null;
        foreach ($surveyPages as $surveyPage) {
            $spId = $surveyPage['id'];
            if ($spId == $page) {
                $currentPage = $surveyPage;
            } elseif ($currentPage != null) {
                $nextPage = $spId;
                break;
            }
        }

        // Is there a next page?
        $isLastPage = true;
        if ($nextPage != null && is_numeric($nextPage)) {
            $isLastPage = false;
        }

        // No pages in this survey? Bail out.
        if (empty($currentPage)) {
            LogUtil::registerError($this->__('Error! This survey has no pages.'));
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        // Fetch the current selections
        $responses = SessionUtil::getVar($this->name . '_responses');

        // To correctly determine which selections to display and which to hide, we need to have a
        // list of dependencies for all questions from previous pages. 

        // Find all previous pages
        $previousPages = array();
        foreach ($surveyPages as $surveyPage) {
            $spId = $surveyPage['id'];
            if ($surveyPage['weight'] < $currentPage['weight']) {
                $previousPages[$spId] = $spId;
            } else {
                break;
            }
        }

        $failedDependencyChecks = array();
        // Now examine all questions that are in the current page to determine
        // if their dependency requirements would eliminate them from being displayed in this page.
        foreach ($allQuestions as $question) {
            $failedDependencyCheck = false;

            // We don't care about questions in pages other than this one.
            if ($question['page']['id'] != $page) {
                continue;
            }

            foreach ($question['dependencies'] as $requiredQuestionId => $requiredValue) {
                // 0 = "Any Selection"
                if (!$requiredValue) {
                    continue;
                }

                // Identify the properties of the question which bears a requirement
                $requiredQuestion = $allQuestions[$requiredQuestionId];

                // Only consider question requirements for questions from previous steps.
                if (!isset($previousPages[$requiredQuestion['page']['id']])) {
                    continue;
                }

                // Is there a response recorded for the question which bears a requirement?
                $responseForQuestion = $responses[$requiredQuestionId];

                if (empty($responseForQuestion)) {
                    // There was no response recorded for the question which bears a requirement. Fail.
                    $failedDependencyCheck = true;
                    break;
                }

                // Requirement validation depends on question type
                if (!$questionHandlers[$question['questionType']]->validateDependencies($requiredQuestion, $requiredValue, $responseForQuestion)) {
                    $failedDependencyCheck = true;
                    break;
                }
            }
            
            $failedDependencyChecks[$question['id']] = $failedDependencyCheck;
        }

        $questionsInCurrentPage = array();
        // Check to make sure all required questions in previous pages have values.
        foreach ($allQuestions as $question) {
            if ($question['page']['id'] == $page) {
                // Flag all questions in the current step.
                $questionsInCurrentPage[$question['id']] = $question;
            } elseif (isset($previousPages[$question['page']['id']]) && $question['required']) {
                // The question is in a previous step and required

                $myResponse = $responses[$question['id']];

                // Validate the input
                if ($questionHandlers[$question['questionType']]->validateInput($question, $myResponse)) {
                    continue;
                }

                // Invalid input, so we redirect here.
                // Since $allQuestions is ordered by overall occurance, we can just go back to the first required question that's missing.
                SessionUtil::setVar($this->name . '_missing_required', $question['id']);
                return $this->redirect(ModUtil::url($this->name, 'user', 'display', array('ot' => 'survey', 'id' => $id, 'page' => $question['page']['id'])));
            }
        }

        // We can't cache because the output is heavily dependent on the user's session data.
        $this->view->setCaching(Zikula_View::CACHE_DISABLED);

        $viewHelper = new SurveyManager_Util_View($this->serviceManager);
        $templateFile = $viewHelper->getViewTemplate($this->view, 'user', $objectType, 'display', $args);
        
        // set cache id
        $component = $this->name . ':' . ucwords($objectType) . ':';
        $instance = $instanceId . '::';
        $accessLevel = ACCESS_READ;
        if (SecurityUtil::checkPermission($component, $instance, ACCESS_COMMENT)) $accessLevel = ACCESS_COMMENT;
        if (SecurityUtil::checkPermission($component, $instance, ACCESS_EDIT)) $accessLevel = ACCESS_EDIT;
        $this->view->setCacheId($objectType . '|' . $instanceId . '|a' . $accessLevel);

        // assign output data to view object.
        $this->view->assign('survey', $survey)
                   ->assign('page', $currentPage)
                   ->assign('questionsInCurrentPage', $questionsInCurrentPage)
                   ->assign('questionHandlers', $questionHandlers)
                   ->assign('failedDependencyChecks', $failedDependencyChecks)
                   ->assign('allQuestions', $allQuestions)
                   ->assign('missingQuestion', $missingQuestion)
                   ->assign('isLastPage', $isLastPage)
                   ->assign('responses', $responses)
                   ->assign('maxFileSizeB', DataUtil::formatForDisplay($this->getVar('maxFileSizeKb') * 1024))
                   ->assign('currentUrlObject', $currentUrlObject)
                   ->assign($repository->getAdditionalTemplateParameters('controllerAction', $utilArgs));

        // fetch and return the appropriate template
        return $viewHelper->processTemplate($this->view, 'user', $objectType, 'display', $args, $templateFile);
    }
    
    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function processPage($args)
    {
        $objectType = 'survey';
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $id = (isset($args['id']) && !empty($args['id'])) ? $args['id'] : (int) $this->request->request->filter('id', 0, FILTER_VALIDATE_INT);
        $page = (isset($args['page']) && !empty($args['page'])) ? $args['page'] : (int) $this->request->request->filter('page', 0, FILTER_VALIDATE_INT);
        if (!$id || !SecurityUtil::checkPermission($this->name . ':Survey:', $id . '::', ACCESS_READ)) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }
        if (!$page || !SecurityUtil::checkPermission($this->name . ':Page:', $page . '::', ACCESS_READ)) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'display', array('ot' => 'survey', 'id' => $id)));
        }

        // Select the survey
        $survey = ModUtil::apiFunc($this->name, 'selection', 'getSurveyWithData', array('id' => $id));

        // Identify the page and collect questions
        $currentPage = null;
        $nextPage = null;
        $allQuestionsInSurvey = array();
        foreach ($survey['pages'] as $surveyPage) {
            foreach ($surveyPage['questions'] as $question) {
                $allQuestionsInSurvey[$question['id']] = $question;
            }
            $spId = $surveyPage['id'];
            if ($spId == $page) {
                $currentPage = $surveyPage;
            } elseif ($currentPage != null) {
                $nextPage = $spId;
                break;
            }
        }

        $oldResponses = SessionUtil::getVar($this->name . '_responses');
        if (!is_array($oldResponses)) {
            $oldResponses = array();
        }

        // Fetch the data that was entered in this step
        $newResponses = (isset($args['responses']) && !empty($args['responses'])) ? $args['responses'] : $this->request->request->get('responses', array());

        $helper = new SurveyManager_Util_Manual($this->serviceManager);
        $docRoot = $helper->getDocumentRoot();

        // response value post processing
        $questionHandlers = array();
        foreach ($currentPage['questions'] as $question) {
            if (!isset($questionHandlers[$question['questionType']])) {
                $questionTypeClassName = $helper->getQuestionTypeHandler($question['questionType']);
                $questionHandlers[$question['questionType']] = new $questionTypeClassName($this->serviceManager);
            }

            $questionId = $question['id'];
            $oldResponse = isset($oldResponses[$questionId]) ? $oldResponses[$questionId] : null;
            $newResponses[$questionId] = $questionHandlers[$question['questionType']]->processPostEdit($question, $newResponses[$questionId], $oldResponse);
        }

        // Write in the session variable
        $completeResponses = $helper->array_merge_keys($oldResponses, $newResponses);
        SessionUtil::setVar($this->name . '_responses', $completeResponses);

        // Is there a next page?
        if ($nextPage != null && is_numeric($nextPage)) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'display', array('ot' => 'survey', 'id' => $id, 'page' => $nextPage)));
        }

        // Store in the response; we're done.
        $this->finishSurveyResponse($survey, $completeResponses, $questionHandlers, $allQuestionsInSurvey, $helper);

        // Redirect
        $redirectUrl = ModUtil::url($this->name, 'user', 'thankYou', array('id' => $id));
        if (!empty($survey['thankYouAlternativeUrl'])) {
            $redirectUrl = str_replace('__RESID__', $responseObj->getId(), $survey['thankYouAlternativeUrl']);
        }
        return $this->redirect($redirectUrl);
    }

    /**
     * Performs the finish of a certain survey response.
     */
    private function finishSurveyResponse($survey, $responses, $questionHandlers, $allQuestionsInSurvey, $helper)
    {
        // Check Captcha and other validation hooks
        $hookAreaPrefix = 'surveymanager.ui_hooks.surveys';
        // Let any hooks perform additional validation actions
        $hook = new Zikula_ValidationHook($hookAreaPrefix . '.validate_edit', new Zikula_Hook_ValidationProviders());
        $validators = $this->notifyHooks($hook)->getValidators();
        if ($validators->hasErrors()) {
            return $this->redirect(System::serverGetVar('HTTP_REFERER'));
        }

        // Format the values nicely
        foreach ($responses as $questionId => $responseValue) {
            $questionType = $allQuestionsInSurvey[$questionId]['questionType'];

            if (!isset($questionHandlers[$questionType])) {
                $questionTypeClassName = $helper->getQuestionTypeHandler($questionType);
                $questionHandlers[$questionType] = new $questionTypeClassName($this->serviceManager);
            }

            $responses[$questionId] = $questionHandlers[$questionType]->formatValue($allQuestionsInSurvey[$questionId], $responseValue);
        }

        $userIpAddress = System::serverGetVar('REMOTE_ADDR');

        $responseObj = new SurveyManager_Entity_Response();
        $responseObj->setIpAddress($userIpAddress);
        $responseObj->setResponseTimestamp(date('U'));
        $responseObj->setFeatured(false);
        $survey->addResponses($responseObj);
        $this->entityManager->persist($responseObj);

        $responseData = array();

        $emailFrom = $nameId = '';
        foreach ($responses as $questionId => $responseValue) {
            if (empty($responseValue)) {
                $responseValue = '';
            }

            $responseQuestion = null;
            foreach ($allQuestionsInSurvey as $question) {
                if ($question['id'] != $questionId) {
                    continue;
                }
                $responseQuestion = $question;
                break;
            }

            $responseDataObj = new SurveyManager_Entity_ResponseData();
            $responseDataObj->setResponseValue($responseValue);
            $responseObj->addAnswers($responseDataObj);
            $responseQuestion->addAnswers($responseDataObj);
            $this->entityManager->persist($responseDataObj);

            $allQuestionsInSurvey[$questionId]['response'] = $responseValue;

            if ($allQuestionsInSurvey[$questionId]['questionType'] == 'email_from' && empty($emailFrom)) {
                $emailFrom = $responseDataObj['responseValue'];
            }
            if ($allQuestionsInSurvey[$questionId]['questionType'] == 'name_id' && empty($nameId)) {
                $nameId = $responseDataObj['responseValue'];
            }
        }

        $this->entityManager->flush();

        // Update the IP count
        $ipCount = $this->getVar('ip_count');
        if (!is_array($ipCount)) {
            $ipCount = array();
        }
        $ipCount[$id][$userIpAddress]++;
        $this->setVar('ip_count', $ipCount);

        $this->view->setCaching(Zikula_View::CACHE_DISABLED);

        $this->sendEmails($survey, $allQuestionsInSurvey, $questionHandlers, $responseObj, $nameId, $emailFrom);

        // Clear out the session vars
        SessionUtil::delVar($this->name . '_responses');
    }

    /**
     * Sends emails for notification and confirmation after a survey response has been completed.
     */
    private function sendEmails($survey, $allQuestionsInSurvey, $questionHandlers, $responseObj, $nameId, $emailFrom)
    {
        if (!ModUtil::available('Mailer')) {
            return;
        }

        $this->view->assign('survey', $survey)
                   ->assign('questions', $allQuestionsInSurvey)
                   ->assign('questionHandlers', $questionHandlers)
                   ->assign('response', $responseObj)
                   ->assign('host', System::serverGetVar('HTTP_HOST'));

        $bodyHtmlNotification = $this->view->fetch('email/admin_notify.tpl');
        $bodyHtmlConfirmation = $this->view->fetch('email/confirmation.tpl');

        $this->view->clear_all_assign();

        $bodyTextNotification = $this->convertHTMLToPlain($bodyHtmlNotification);
        $bodyTextConfirmation = $this->convertHTMLToPlain($bodyHtmlConfirmation);

        $this->view->assign('body', $bodyHtmlNotification)
                    ->assign('styles', $this->collectStyleData($docRoot));
        $bodyHtmlEmailNotification = $this->view->fetch('email/template.tpl');

        $this->view->assign('body', $bodyHtmlConfirmation);
        $bodyHtmlEmailConfirmation = $this->view->fetch('email/template.tpl');

        $this->sendNotificationMails($nameId, $emailFrom, $survey['recipients'], $bodyTextNotification, $bodyHtmlEmailNotification);

        $subject = ((!empty($survey['confirmationSubject'])) ? $survey['confirmationSubject'] : $this->__('Survey Confirmation'));
        $this->sendConfirmationMailToOwner($emailFrom, $subject, $survey['confirmationBody'], $bodyTextConfirmation, $bodyHtmlEmailConfirmation);
    }

    /**
     * Collects styles to be included within the email body.
     */
    private function collectStyleData($docRoot)
    {
        // Collect stylesheet to manually write them into the email header
        $styleData = array();

        $stylePath = $docRoot . 'modules/' . $this->name . '/style/';

        // Load the module stylesheets
        if (!($styleDataSingle = file_get_contents($stylePath . 'style.css')) === FALSE) {
            $styleData['module stylesheet style.css'] = $styleDataSingle;
        }
        if (!($styleDataSingle = file_get_contents($stylePath . 'manual.css')) === FALSE) {
            $styleData['module stylesheet manual.css'] = $styleDataSingle;
        }

        $styles = '';
        foreach ($styleData as $stylesheetName => $styleDataSingle) {
            $styles .= "/*$stylesheetName*/\n\n" . $styleDataSingle . "\n\n";
        }

        return $styles;
    }

    /**
     * Sends notification emails.
     */
    private function sendNotificationMails($nameId, $emailFrom, $surveyRecipientList, $bodyText, $bodyHtml)
    {
        // Mail the submission reports
        $result = true;

        // collect recipients
        $recipients = $this->getVar('submissionRecipients', array());
        if (empty($recipients)) {
            $recipients = array();
        }

        $surveyRecipients = $surveyRecipientList;
        if (empty($surveyRecipients)) {
            $surveyRecipients = array();
        }

        $recipients = array_merge($recipients, $surveyRecipients);
        if (!count($recipients)) {
            return $result;
        }

        $sitename = System::getVar('sitename');
        $adminEmail = System::getVar('adminmail');

        foreach ($recipients as $recipientEmail) {
            $mailArgs = array(
                'fromname' => empty($nameId) ? (empty($emailFrom) ? null : $emailFrom) : $nameId,
                'fromaddress' => empty($emailFrom) ? $adminEmail : $emailFrom,
                'toaddress' => $recipientEmail,
                'subject' => ((!empty($survey['responseSubject'])) ? $survey['responseSubject'] : $this->__('Survey Response Report')),
                'body' => $bodyHtml,
                'alt_body' => $bodyText,
                'html' => true);
            $result &= $this->sendSingleMail($mailArgs);
        }
        return $result;
    }

    /**
     * Sends confirmation email.
     */
    private function sendConfirmationMailToOwner($emailFrom, $subject, $bodyRaw, $bodyText, $bodyHtml)
    {
        // Mail user confirmation, but only if there is a confirmation email body
        $bodyEmailConfirmationNoTags = str_replace('&nbsp;', '', trim(strip_tags($bodyRaw)));
        if (empty($emailFrom) || empty($bodyEmailConfirmationNoTags)) {
            return true;
        }

        $sitename = System::getVar('sitename');
        $adminEmail = System::getVar('adminmail');

        $mailArgs = array(
            'fromname' => empty($sitename) ? $adminEmail : $sitename,
            'fromaddress' => $adminEmail,
            'toaddress' => $emailFrom,
            'subject' => $subject,
            'body' => $bodyHtml,
            'alt_body' => $bodyText,
            'html' => true);

        return $this->sendSingleMail($mailArgs);
    }

    /**
     * Sends a single email using the Mailer interface (which is using SwiftMailer or phpMailer).
     */
    private function sendSingleMail($mailArgs)
    {
        $result = ModUtil::apiFunc('Mailer', 'user', 'sendmessage', $mailArgs);
        if (empty($result)) {
            LogUtil::registerError('Error sending email to ' . $mailArgs['toaddress'] . '.');   
            return false;
        }
        return $result;
    }

    private function convertHTMLToPlain($source)
    {
        $plain = preg_replace("/<br\s\/?>/", "\r\n", $source);
        $plain = strip_tags($plain);
        return $plain;
    }

    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function thankYou($args)
    {
        $objectType = 'survey';
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $id = (isset($args['id']) && !empty($args['id'])) ? $args['id'] : (int) $this->request->query->filter('id', 0, FILTER_VALIDATE_INT);
        //$this->throwNotFoundUnless(($id > 0), $this->__('Error! Invalid identifier received.'));
        if (!is_numeric($id) || $id < 1) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        SessionUtil::delVar($this->name . '_responses');

        $this->view->caching = false;    
        $survey = ModUtil::apiFunc($this->name, 'selection', 'getEntity', array('ot' => $objectType, 'id' => $id));

        $this->view->assign('survey', $survey);

        // return template
        return $this->view->fetch('user/thankYou.tpl');
    }

    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function clearResponses($args)
    {
        $objectType = 'survey';
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $id = (isset($args['id']) && !empty($args['id'])) ? $args['id'] : (int) $this->request->query->filter('id', 0, FILTER_VALIDATE_INT);

        if ($id > 0) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'display', array('ot' => 'survey', 'id' => $id)));
        } else {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }
    }
    
    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function viewResponse($args)
    {
        $objectType = 'response';
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $id = (isset($args['id']) && !empty($args['id'])) ? $args['id'] : (int) $this->request->query->filter('id', 0, FILTER_VALIDATE_INT);
        //$this->throwNotFoundUnless(($id > 0), $this->__('Error! Invalid identifier received.'));
        if (!is_numeric($id) || $id < 1) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        $response = $this->selectEntity(array('ot' => $objectType, 'id' => $id));
        //$this->throwNotFoundUnless($response, $this->__('Error! Invalid identifier received.'));
        if (!$response) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', $id . '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        // Select pages with questions for this survey
        $surveyPages = $this->selectEntities(array('ot' => 'page', 'where' => 'tblSurvey.id = \'' . $response['survey']['id'] . '\''));

        $helper = new SurveyManager_Util_Manual($this->serviceManager);

        // Collect questions ordered by their appearance in the survey
        $orderedQuestions = array();
        $questionHandlers = array();
        foreach ($surveyPages as $surveyPage) {
            foreach ($page['questions'] as $question) {
                $orderedQuestions[$question['id']] = $question;

                $questionTypeClassName = $helper->getQuestionTypeHandler($question['questionType']);
                if (!isset($questionHandlers[$question['questionType']])) {
                    $questionHandlers[$question['questionType']] = new $questionTypeClassName($this->serviceManager);
                }
            }
        }

        // Assign responses to questions
        foreach ($response['answers'] as $datum) {
            $questionId = $datum['question']['id'];
            $orderedQuestions[$questionId]['response'] = stripslashes($datum['responseValue']);
        }

        $this->view->setCaching(Zikula_View::CACHE_DISABLED);

        $this->view->assign('response', $response)
                   ->assign('questions', $orderedQuestions)
                   ->assign('questionHandlers', $questionHandlers);

        $viewHelper = new SurveyManager_Util_View($this->serviceManager);

        $templateFile = $viewHelper->getViewTemplate($this->view, 'user', $objectType, 'view', $args);

        // fetch and return the appropriate template
        return $viewHelper->processTemplate($this->view, 'user', $objectType, 'view', $args, $templateFile);
    }

    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function viewFeatured($args)
    {
        // parameter specifying which type of objects we are treating
        $objectType = 'response';
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $surveyid = (isset($args['sid']) && !empty($args['sid'])) ? $args['sid'] : (int) $this->request->query->filter('sid', 0, FILTER_VALIDATE_INT);
        $page = (isset($args['page']) && !empty($args['page'])) ? $args['page'] : (int) $this->request->query->filter('page', 0, FILTER_VALIDATE_INT);

        $repository = $this->entityManager->getRepository($this->name . '_Entity_' . ucfirst($objectType));

        // parameter for used sorting field
        $sort = (isset($args['sort']) && !empty($args['sort'])) ? $args['sort'] : $this->request->query->filter('sort', '', FILTER_SANITIZE_STRING);
        if (empty($sort) || !in_array($sort, $repository->getAllowedSortingFields())) {
            $sort = $repository->getDefaultSortingField();
        }

        // parameter for used sort order
        $sdir = (isset($args['sortdir']) && !empty($args['sortdir'])) ? $args['sortdir'] : $this->request->query->filter('sortdir', '', FILTER_SANITIZE_STRING);
        $sdir = strtolower($sdir);
        if ($sdir != 'asc' && $sdir != 'desc') {
            $sdir = 'asc';
        }
        
        $selectionArgs = array(
            'ot' => $objectType,
            'where' => '',
            'orderBy' => $sort . ' ' . $sdir
        );

        // the current offset which is used to calculate the pagination
        $currentPage = (int) (isset($args['pos']) && !empty($args['pos'])) ? $args['pos'] : $this->request->query->filter('pos', 1, FILTER_VALIDATE_INT);
    
        // the number of items displayed on a page for pagination
        $resultsPerPage = (int) (isset($args['num']) && !empty($args['num'])) ? $args['num'] : $this->request->query->filter('num', 0, FILTER_VALIDATE_INT);
        if ($resultsPerPage == 0) {
            $resultsPerPage = $this->getVar('pageSize', 10);
        }

        // set cache id
        $cacheId = 'view|ot_' . $objectType . '_sort_' . $sort . '_' . $sdir;
        $this->view->setCacheId($cacheId . '_amount_' . $resultsPerPage . '_page_' . $currentPage);

        // if page is cached return cached content
        if ($this->view->is_cached($templateFile)) {
            return $viewHelper->processTemplate($this->view, 'user', $objectType, 'view', $args, $templateFile);
        }

        $selectionArgs['where'] = 'tbl.featured = 1';

        $survey = null;
        if ($surveyid && is_numeric($surveyid)) {
            $survey = $this->selectEntity(array('ot' => 'survey', 'id' => $surveyid));
            $selectionArgs['where'] .= ' AND tblSurvey.id = \'' . $surveyid . '\'';
        }

        if (!is_numeric($page)) {
            $sessionPage = SessionUtil::getVar($this->name . '_view_featured_page');
            if ($session_page && is_numeric($sessionPage)) {
                $page = $sessionPage;
            } else {
                $page = 0;
                SessionUtil::setVar($this->name . '_view_featured_page', $page);
            }
        } else {
            SessionUtil::setVar($this->name . '_view_featured_page', $page);
        }

        // retrieve response list with pagination
        $selectionArgs['currentPage'] = $currentPage;
        $selectionArgs['resultsPerPage'] = $resultsPerPage;
        list($responses, $objectCount) = ModUtil::apiFunc($this->name, 'selection', 'getEntitiesPaginated', $selectionArgs);

        $indexedResponses = array();
        foreach ($responses as $response) {
            $indexedResponses[$response['id']] = $response;
        }

        $orderedResponses = array();
        if ($surveyid && is_numeric($surveyid)) {
            $featuredOrders = $this->getVar('featuredOrders', array());
            if (!is_array($featuredOrders)) {
                $featuredOrders = array();
            }

            $featuredOrder = $featuredOrders[$surveyid];

            foreach ($featuredOrder as $k => $responseId) {
                $orderedResponses[$k] = $responses[$responseId];
            }
        } else {
            $orderedResponses = array_values($responses);
        }

        $this->view->setCaching(Zikula_View::CACHE_DISABLED);

        $this->view->assign('orderedResponses', $orderedResponses)
                   ->assign('page', $page)
                   ->assign('survey', $survey)
                   ->assign('currentPage', $currentPage)
                   ->assign('pager', array('numitems'     => $objectCount,
                                           'itemsperpage' => $resultsPerPage));

        // return template
        return $this->view->fetch('user/viewFeatured.tpl');
    }

    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function displayFeatured($args)
    {
        $objectType = 'survey';

        $id = (isset($args['id']) && !empty($args['id'])) ? $args['id'] : (int) $this->request->query->filter('id', 0, FILTER_VALIDATE_INT);
        //$this->throwNotFoundUnless(($id > 0), $this->__('Error! Invalid identifier received.'));
        if (!is_numeric($id) || $id < 1) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', $id . '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $cacheId = 'featured_' . $id;
        $this->view->setCacheId($cacheId);
        $template = 'user/displayFeatured.tpl';

        if ($this->view->is_cached($template)) {
            return "<!-- Featured responses {$cacheId} cached: -->\n" . $this->view->fetch($template);
        }

        $survey = $this->selectEntity(array('ot' => $objectType, 'id' => $id));

        //$responses = $survey['responses'];
        $responses = $this->selectEntities(array('ot' => 'response', 'where' => 'tbl.featured = 1 AND tblSurvey.id = \'' . $id . '\''));

        // select pages with questions
        $pages = $this->selectEntities(array('ot' => 'page', 'where' => 'tblSurvey.id = \'' . $id . '\''));

        $indexedQuestions = array();
        foreach ($pages as $surveyPage) {
            foreach ($surveyPage['questions'] as $question) {
                $indexedQuestions[$question['id']] = $question;
            }
        }

        $serviceManager = ServiceUtil::getManager();
        $helper = new SurveyManager_Util_Manual($serviceManager);
        $questionHandlers = array();
        $indexedResponses = array();
        foreach ($responses as $response) {
            $responseId = $response['id'];
            $response['name_id'] = $helper->findResponseValue($response['id'], 'name_id', $response);
            $response['email_from'] = $helper->findResponseValue($response['id'], 'email_from', $response);
            $indexedResponses[$responseId] = $response;

            // select data with relation to the question
            $responseData = $this->selectEntities(array('ot' => 'responseData', 'where' => 'tblResponse.id = \'' . $response['id'] . '\''));
            foreach ($responseData as $datum) {
                $questionId = $datum['question']['id'];
                if (!isset($indexedQuestions[$questionId]['responses'])) {
                    $indexedQuestions[$questionId]['responses'] = array();
                }
                $responseValues = $indexedQuestions[$questionId]['responses'];
                $responseValues[$responseId] = $datum['responseValue'];
                $indexedQuestions[$questionId]['responses'] = $responseValues;

                if (!isset($questionHandlers[$datum['question']['questionType']])) {
                    $questionTypeClassName = $helper->getQuestionTypeHandler($datum['question']['questionType']);
                    $questionHandlers[$datum['question']['questionType']] = new $questionTypeClassName($serviceManager);
                }
            }
        }

        // Set up the ordering
        $featuredOrders = $this->getVar('featuredOrders', array());
        if (!is_array($featuredOrders)) {
            $featuredOrders = array();
        }

        $featuredOrder = $featuredOrders[$id];

        $this->view->setCaching(Zikula_View::CACHE_DISABLED);

        $renderedResponses = $orderedResponses = array();

        foreach ($featuredOrder as $key => $rid) {
            $this->view->clear_all_assign();
            $this->view->assign('response', $indexedResponses[$rid])
                       ->assign('questions', $indexedQuestions)
                       ->assign('questionHandlers', $questionHandlers);

            $renderedResponses[$rid] = $this->view->fetch('user/previewFeatured.tpl');
            $orderedResponses[$key] = $responses[$rid];
        }

        $this->view->clear_all_assign();

        $this->view->assign('survey', $survey)
                   ->assign('responses', $orderedResponses)
                   ->assign('renderedResponses', $renderedResponses)
                   ->assign('questions', $indexedQuestions);

        // return template
        return $this->view->fetch('user/displayFeatured.tpl');
    }

    /**
     * This is a custom method. Documentation for this will be improved in later versions.
     *
     * @param array $args List of arguments.
     *
     * @return mixed Output.
     */
    public function detailFeatured($args)
    {
        $objectType = 'response';

        $id = (isset($args['id']) && !empty($args['id'])) ? $args['id'] : (int) $this->request->query->filter('id', 0, FILTER_VALIDATE_INT);
        //$this->throwNotFoundUnless(($id > 0), $this->__('Error! Invalid identifier received.'));
        if (!is_numeric($id) || $id < 1) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . ':' . ucwords($objectType) . ':', $id . '::', ACCESS_OVERVIEW), LogUtil::getErrorMsgPermission());

        $response = $this->selectEntity(array('ot' => 'response', 'id' => $id));
        //$this->throwNotFoundUnless($response && $response['featured'], $this->__('Error! Invalid identifier received.'));
        if (!$response || !$response['featured']) {
            return $this->redirect(ModUtil::url($this->name, 'user', 'view'));
        }

        // Order questions by their appearance in the survey
        $survey = ModUtil::apiFunc($this->name, 'selection', 'getSurveyWithData', array('id' => $response['survey']['id']));

        // Fetch the actual response data
        $responseData = $this->getResponseData($survey, $id, $response);

        $helper = new SurveyManager_Util_Manual($this->serviceManager);
        $response['name_id'] = $helper->findResponseValue($id, 'name_id', $response);
        $response['email_from'] = $helper->findResponseValue($id, 'email_from', $response);

        $helper = new SurveyManager_Util_Manual($this->serviceManager);
        $orderedQuestions = array();
        $questionHandlers = array();
        foreach ($survey['pages'] as $page) {
            foreach ($page['questions'] as $question) {
                $orderedQuestions[$question['id']] = $question;

                $questionTypeClassName = $helper->getQuestionTypeHandler($question['questionType']);
                if (!isset($questionHandlers[$question['questionType']])) {
                    $questionHandlers[$question['questionType']] = new $questionTypeClassName($this->serviceManager);
                }
            }
        }

        $this->view->setCaching(Zikula_View::CACHE_DISABLED);

        $this->view->assign('response', $response)
                   ->assign('questions', $orderedQuestions)
                   ->assign('questionHandlers', $questionHandlers)
                   ->assign('data', $responseData);

        // return template
        return $this->view->fetch('user/detailFeatured.tpl');
    }

    private function getResponseData($survey, $responseId, $response = null)
    {
        if ($response == null) {
            $response = $this->selectEntity(array('ot' => 'response', 'id' => $responseId));
        }

        if (!$survey || !$response) {
            return false;
        }

        $helper = new SurveyManager_Util_Manual($this->serviceManager);

        $allQuestions = array();
        foreach ($survey['pages'] as $page) {
            foreach ($page['questions'] as $question) {
                $allQuestions[$question['id']] = $question;
            }
        }

        $responseData = array();
        foreach ($allQuestions as $questionId => $question) {
            foreach ($response['answers'] as $datum) {
                if ($datum['question']['id'] != $questionId) {
                    continue;
                }
                $responseData[$questionId] = $datum['responseValue'];
                break;
            }
        }

        return $responseData;
    }

    private function selectEntity($selectionArgs)
    {
        return ModUtil::apiFunc($this->name, 'selection', 'getEntity', $selectionArgs);
    }

    private function selectEntities($selectionArgs)
    {
        return ModUtil::apiFunc($this->name, 'selection', 'getEntities', $selectionArgs);
    }
}
