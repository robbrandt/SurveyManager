<?php
/**
 * SurveyManager.
 *
 * @copyright Zikula Development Team
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package SurveyManager
 * @author Zikula Development Team <info@zikula.org>.
 * @link http://zikula.org
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.5.5 (http://modulestudio.de) at Tue Aug 21 20:13:14 CEST 2012.
 */

/**
 * Utility class for upload related helper methods.
 */
class SurveyManager_Util_Upload extends Zikula_AbstractBase
{
    private $targetDir = '';
    private $targetSubDir = '';
    private $defaultSubDir = 'general';
    private $error = false;
    private $debugOutput = array();
    private $supportedFormats = array('.gif', '.png', '.jpg', '.jpeg');
    private $docRoot = '';
    private $helper = null;

    /**
     * The constructor.
     */
    public function __construct(Zikula_ServiceManager $serviceManager, $inTargetDir, $inTargetSubDir = '')
    {
        parent::__construct($serviceManager);

        $this->helper = new SurveyManager_Util_Manual($serviceManager);
        $this->docRoot = $this->helper->getDocumentRoot();

        $this->setTargetDir($inTargetDir);
        $this->setTargetSubDir($inTargetSubDir);
    }

    public function handleUpload($file, $hashname = false, $debug = false)
    {
        //This could take a while.
        set_time_limit(300);
        ini_set('memory_limit', '50M');

        $this->debugOutput = array();
        $this->error = false;

        if ($debug) {
            $this->addDebugOutput('Start of handleUpload()');
        }

        if (empty($file) || !is_array($file)) {
            if ($debug) {
                $this->addDebugOutput('The file param was empty!');
                $this->error = true;
            }
            return;
        }

        if ($file['error'] == 1 || $file['error'] == 2) {
            $this->addDebugOutput('PHP reports file upload error ' . $file['error'] . '; the file was probably too big.');
            $this->error = true;
        }
    
        $targetDir = $this->getTargetDir();
        $targetSubDir = $this->getTargetSubDir();
    
        $subDir = '';
        if (empty($targetSubDir)) {
            $subDir = (string)$this->defaultSubDir;
        } else {
            $subDir = (string)$targetSubDir;
        }

        $uploadPath = '';
        if (!empty($subDir)) {
            $uploadPath = $this->docRoot . $targetDir . '/' . $subDir;
        } else {
            $uploadPath = $this->docRoot . $targetDir;
        }

        // Is the directory available?
        $is_dir = is_dir($uploadPath);
        if (!$is_dir) {
            if ($debug) {
                $this->addDebugOutput("$uploadpath did not exist; attempting to create it.");
            }

            $result = mkdir($uploadpath, 0775);
            if (!$result) {
                if ($debug) {
                    $this->addDebugOutput("failed to create $uploadpath");
                    $this->error = true;
                }
                return;
            }
        }

        $fileName = basename($file['name']);
        $fileName = stripslashes($fileName);
        $fileName = str_replace("'", '', $fileName);

        if ($hashname) {
            $ext = strrchr($fileName, '.');
            $nameWithoutExt = str_replace($ext, '', $fileName);
            $fileName = $nameWithoutExt . '_' . substr(md5(rand() * time()), 0, 8) . $ext;
        }
        
        if ($debug) {
            $this->addDebugOutput("The file name is $fileName");
        }

        $uploadFile = $uploadPath . '/' . $fileName;

        if ($debug) {
            $this->addDebugOutput("moving from $file[tmp_name] to $uploadFile");
        }

        if (file_exists($uploadFile)) {
            unlink($uploadFile);
        }

        $result = move_uploaded_file($file['tmp_name'], $uploadFile);

        if (is_file($uploadFile)) {
            if (is_dir($uploadPath)) {
                chmod($uploadPath, 0775);
            }
            chmod($uploadFile, 0664);
        } else {
            chmod($uploadFile, 0775);
        }

        if ($result) {
            $returnUrl = /*$this->docRoot . */$targetDir . '/' . $subDir . '/' . $fileName;
            return $returnUrl;
        }

        if ($debug) {
            $this->addDebugOutput("failed to move_uploaded_file()");
            $this->error = true;
        }
    }

    /**
     * Makes a copy of the photo at $url, then it calls constrainPhoto with $maxWidth and $maxHeight.
     * Add $name_addition after the basename of the file (right before the suffix). e.g.,
     * given $name_addition "_thumb", "my_picture.jpg" becomes "my_picture_thumb.jpg".
     */
    public function constrainPhotoCopy($url, $maxWidth, $maxHeight, $name_addition, $debug = false)
    {
        $suffix = $this->helper->getSuffix(basename($url));
        $thumb_path = str_replace($suffix, $name_addition . $suffix, $url);
        
        if (!copy($this->docRoot . $url, $this->docRoot . $thumb_path)) {
            $this->error = true;
            $this->addDebugOutput("copy() failed from $url to $thumb_path");
            return false;
        }
        return $this->constrainPhoto($thumb_path, $maxWidth, $maxHeight, $debug);
    }

    /**
     * Resizes pictures correctly.
     */
    private function constrainPhoto($url, $maxWidth, $maxHeight, $debug = false)
    {
        //This could take a while.
        set_time_limit(300);
        ini_set("memory_limit", "50M");
    
        $this->debugOutput = array();
        $this->error = false;
    
        if (empty($url)) {
            return false;
        }

        if ($debug) {
            $this->addDebugOutput("constraining $url to $maxWidth x $maxHeight. Debugging on.");
        }

        $pic_filename = basename($url);
        $suffix = strtolower($this->helper->getSuffix($pic_filename));

        $valid_image = in_array(strtolower($suffix), $this->supportedFormats);
        
        if (!$valid_image) {
            $this->addDebugOutput('Not a valid image file. Your image must be a JPG, PNG or GIF, but instead it had suffix ' . $suffix);
            $this->error = true;
            return $url;
        }

        //Determine the UNIX path to the picture. Attempt to accept input of the following formats:
        //http://www.hostname.com/path/to/file.jpg
        //www.hostname.com/path/to/file.jpg
        //path/to/file.jpg

        $fullpath = str_replace('http://' . $GLOBALS['HTTP_HOST'], $this->docRoot, $url);
        $fullpath = str_replace($GLOBALS['HTTP_HOST'], $this->docRoot, $fullpath);

        if (strpos($fullpath, $this->docRoot) === FALSE) {
            $fullpath = $this->docRoot . '/' . $fullpath;
        }

        // Determine its current height and width
        list($width, $height, $type, $disp) = getimagesize($fullpath);

        $width_perc = $height_perc = 1.00;

        // If either dimension is greater than its apporpriate max,, find the percentage decrease that will
        // result in the greatest dimension being exactly its maximum.
        if ($width > $maxWidth) {
            $width_perc = (float)$maxWidth / (float)$width;
        }
        if ($height > $maxHeight) {
            $height_perc = (float)$maxHeight / (float)$height;
        }

        // Use whatever shrink percentage is *smaller*
        if ($height_perc < $width_perc) {
            $perc = $height_perc;
        } else {
            $perc = $width_perc;
        }

        // Calculate the new_height and new_width
        $newWidth = $width * $perc;
        $newHeight = $height * $perc;

        $this->addDebugOutput("new_width is $newWidth. new_height is $newHeight.");
        
        // Resize the image
        $image_p = imagecreatetruecolor($newWidth, $newHeight);

        if (!$image_p) {
            $this->addDebugOutput("Failed to create a new image.");
        }

        $image = null;

        // Pull the data from the uploaded file
        switch ($suffix) {
            case '.jpg':
            case '.jpeg':
                $image = imagecreatefromjpeg($fullpath);
                break;
            case '.png':
                $image = imagecreatefrompng($fullpath);
                break;
            case '.gif':
                $image = imagecreatefromgif($fullpath);
                break;
        }
        
        if (empty($image)) {
            $this->addDebugOutput("Failed to load image data from $fullpath");
            $this->error = true;
        }
        
        // Copy and resample the smaller version
        if (imagecopyresampled($image_p, $image, 0, 0, 0, 0, $newWidth, $newHeight, $width, $height) === FALSE) {
            $this->addDebugOutput("Failed to resample the image to the correct size ($newWidth x $newHeight)");
        }

        // Output the new image to the new full path
        if (unlink($fullpath) === FALSE) {
            $this->addDebugOutput("Couldn't unlink $fullpath");
            $this->error = true;
        } else {
            if ($debug) {
                $this->addDebugOutput("Unlink $fullpath succeeded");
            }
        }
        
        switch ($suffix) {
            case '.jpg':
            case '.jpeg':
                $result = imagejpeg($image_p, $fullpath, 100);
                break;
            case '.gif':
                $result = imagegif($image_p, $fullpath);
                break;
            case '.png':
                $result = imagepng($image_p, $fullpath);
                break;
        }

        if ($result === FALSE) {
            $this->addDebugOutput("Couldn't write to $fullpath");
            $this->error = true;
            return $url;
        }

        chmod($fullpath, 0664);

        // Only store the new file name is the write was successful.
        $url = str_replace($this->docRoot, '', $fullpath);
        if ($debug) {
            $this->addDebugOutput("Successfully resized $fullpath");
        }
        
        return $url;
    }

    public function getTargetDir()
    {
        return $this->targetDir;
    }

    public function setTargetDir($inTargetDir)
    {
        $this->targetDir = $inTargetDir;
    }

    public function getTargetSubDir()
    {
        return $this->targetSubDir;
    }

    public function setTargetSubDir($inTargetSubDir)
    {
        $this->targetSubDir = $inTargetSubDir;
    }

    /**
     * Returns true if there was an error in the last upload operation.
     */
    public function wasError()
    {
        return $this->error;
    }

    /**
     * Returns an array of plaintext strings representing the debugging output
     * of the most recent upload operation.
     */
    public function getDebugOutput()
    {
        return $this->debugOutput;
    }

    private function addDebugOutput($inString)
    {
        if (!is_array($this->debugOutput)) {
            $this->debugOutput = array();
        }

        $this->debugOutput[] = $inString;
    }
}
